---
title: 'Appendix S2: Landsat Filters'
subtitle: 'lakeCoSTR: An open-source, interactive retrieval tool to facilitate use of the Landsat Collection 2 surface temperature product to estimate lake surface water temperatures'
author: "*Herrick, C, Steele, BG*,  Brentrup, JA, Cook, B, Cottingham, KL, Ducey, M, Johnson, K, Lutz, DA, Palace, M, Sullivan, F, Thompson, M, Trout-Haney, JV, Weathers, KC"
output: word_document
editor_options: 
  markdown: 
    wrap: 90
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# read in libraries and functions
source('R_library.R')

#print r version
R.version$version.string

# point to directories
datadir = '~/GitHub/ids-ne-lakes/data/'
C2_datadir <- '~/GitHub/ids-ne-lakes/data/colab-output/C2/'
```

# Background:

Upon inspection of the Colab-exported histograms, it seemed clear that
some of the ranges of data seemed ecologically unfeasible with some
displaying a range of 20 degrees C or more over the surface of Lake
Sunapee. In this appendix, we explore some of the additional quality
assurance filters that we tried that may be helpful for others using
this tool.

![Landsat 4:
1990-07-21](C:/Users/steeleb/Documents/GitHub/ids-ne-lakes/data/colab-output/C2/histograms/LT04_L1TP_013030_19900721_20200915_02_T1_histo.png){width="3in"}![Landsat
5:
1998-07-23](C:/Users/steeleb/Documents/GitHub/ids-ne-lakes/data/colab-output/C2/histograms/LT05_L1TP_013030_19880723_20200917_02_T1_histo.png){width="3in"}

![Landsat 7:
2018-05-31](C:/Users/steeleb/Documents/GitHub/ids-ne-lakes/data/colab-output/C2/histograms/LE07_L1TP_013030_20180531_20200829_02_T1_histo.png){width="3in"}![Landsat
8:
2020-09-17](C:/Users/steeleb/Documents/GitHub/ids-ne-lakes/data/colab-output/C2/histograms/LC08_L1TP_013030_20200917_20201005_02_T1_histo.png){width="3in"}

Figure S1. Four histograms, one from each Landsat Mission, exhibiting unusual frequency distributions as exported from the lakeCoSTR tool. 

In addition to the possible range-of-value issues shown in Figure S1, there is also evidence of non-unimodal distributions. Because we were intersted in using a single median value to describe the scene, we determined these scenes were not suitable for our analysis.  Note that bimodal
distributions in surface temperature across a lake surface are certainly
ecologically possible outcomes and may be useful for some systems or
analyses. There were also scenes
with negative temperatures reported even though pixels classified as
snow or ice were filtered out in the Colab script. 

Our desire was to create a filter that would filter out the scenes with presumed atmospheric
interference (indicated by grossly large estimated temperature ranges) or those that were not suitable for our analysis
using measurements from the extensive *in-situ* data network at Lake Sunapee.
We used statistical measures of distribution, including quartile values, ranges, and measurement of distribution kurtosis (the
'tailedness' of the distribution). Knowing that we did not filter for
clouds or cloud shadows explicitly in the tool, and given that there is documented interference
with the surface temperature product (Cook, et al., 2014), we also tried a cloud filter to
eliminate some scenes.

# Methods

The filters we explored, listed in order of increased stringency
based on the number of scenes eliminated from analysis, were:

-   **freeze**: removing all scenes whose minimum temperature was below
    0 degrees Celsius

-   **IQR**: *freeze* filter removing scenes that reported
    interquartile temperature ranges greater than 110% in a summary of the *in-situ* temperature
    record

-   **kurtosis**: removing any scenes whose histogram has a kurtosis value
    less than 2

-   **cloud**: *freeze* filter plus removing scenes with cloud cover
    greater than 40%

-   **range**: *freeze* filter plus removing scenes that reported temperature ranges
    greater than 110% observed in a summary of the *in-situ* temperature record

## Load, summarize, and filter data

```{r load data}
#read in previously collated and filtered in-situ data
insitu <- read.csv(paste0(datadir, 'insitu_temp_data_v2021-10-20.csv')) %>% 
  filter(!is.na(lat_dd)) %>% 
  mutate(datetime = as.POSIXct(datetime, tz = 'Etc/GMT+5'))

#read in Collection 2 paired data, an output from the Colab Notebook
C2ST <- read.csv(file.path(C2_datadir,paste0('C2_v2_temp_landsat_paired.csv')))
```

In order to define the maximum acceptable Landsat range from the *in-situ* data, we limited the validation dataset described in section 3.1.2 of the main text
to those values measured between the hours of 9 and 11 am (the
approximate time of Landsat flyover). These values were aggregated to daily values of range, interquartile range, and number of locations contributing the ranges. From
the dail values we calculated the maximum range and interquartile range in the
observed temperature data.

```{r}
# Summarize in-situ to define spread and IQR limits ####

# get range per day during hours of flyover
range_per_date <- insitu %>% 
  mutate(hour = as.numeric(format(datetime, '%H')),
         date = as.Date(datetime)) %>% 
  filter(hour >= 9 & hour < 11) %>% 
  group_by(date) %>% 
  summarize(temp_range = max(temp_degC) - min(temp_degC),
            IQR = IQR(temp_degC, na.rm = T),
            n_locs = length(unique(location)))

#save max observed spread and IQR for further filtering
max_spread <- max(range_per_date$temp_range, na.rm = T)
print('Maximium spread observed is:')
max_spread
max_IQR <- max(range_per_date$IQR, na.rm = T)
print('Maximium interquartile range observed is:')
max_IQR
```

```{r flag}
# Flag C2 data for freezing temps, spread P/F, IQR P/F ####
C2ST <- C2ST %>% 
  mutate(freeze_QAQC = case_when(surface_temp_min < 0 ~ 'F', #pass/fail for freezing temps
                                 TRUE ~ 'P')) %>% 
  mutate(temp_spread = round(surface_temp_max, digits = 1) - round(surface_temp_min, digits = 1)) %>% #calc temp spread; pass/fail for temp spread
  mutate(spread_QAQC = case_when(temp_spread < max_spread*1.1 ~ 'P',
                                 TRUE ~ 'F')) %>% 
  mutate(IQR = round(surface_temp_p75, digits = 1) - round(surface_temp_p25, digits = 1))  %>%  #calc IQR; pass/fail for temp IQR
  mutate(IQR_QAQC = case_when(IQR < max_IQR*1.1 ~ 'P',
                              TRUE ~ 'F'))

# filtered datasets
C2ST_freeze <- C2ST %>% 
  filter(freeze_QAQC == 'P')

C2ST_maxrange <- C2ST %>% 
  filter(freeze_QAQC == 'P' & 
           spread_QAQC == 'P')

C2ST_maxIQR <- C2ST %>% 
  filter(freeze_QAQC == 'P' & 
           IQR_QAQC == 'P')

C2ST_cloud <- C2ST %>% 
  filter(freeze_QAQC == 'P' & cloud_cover <40)

C2ST_kurtosis <- C2ST %>% 
  filter(surface_temp_kurtosis > 2)
```

```{r}
# Deming Regressions ####

# deming regression for C2
C2_deming = deming::deming(C2ST$surface_temp_median ~ C2ST$is_temp_med)
C2_deming_forresid = mcreg(x = C2ST$is_temp_med, y = C2ST$surface_temp_median, method.reg = 'Deming')
C2ST$opt_resid = MCResult.getResiduals(C2_deming_forresid)$optimized
C2ST$filter = 'none'

# deming regression for C2 without freezing temps
C2_freeze_deming = deming::deming(C2ST_freeze$surface_temp_median ~ C2ST_freeze$is_temp_med)
C2_freeze_deming_forresid = mcreg(x = C2ST_freeze$is_temp_med, 
                           y = C2ST_freeze$surface_temp_median, 
                           method.reg = 'Deming')
C2ST_freeze$opt_resid = MCResult.getResiduals(C2_freeze_deming_forresid)$optimized
C2ST_freeze$filter = 'freeze'

# deming regression for C2 without freezing temps and within range
C2_maxrange_deming = deming::deming(C2ST_maxrange$surface_temp_median ~ C2ST_maxrange$is_temp_med)
C2_maxrange_deming_forresid = mcreg(x = C2ST_maxrange$is_temp_med, 
                                  y = C2ST_maxrange$surface_temp_median, 
                                  method.reg = 'Deming')
C2ST_maxrange$opt_resid = MCResult.getResiduals(C2_maxrange_deming_forresid)$optimized
C2ST_maxrange$filter = 'range'

# deming regression for C2 without freezing temps and within IQR
C2_maxIQR_deming = deming::deming(C2ST_maxIQR$surface_temp_median ~ C2ST_maxIQR$is_temp_med)
C2_maxIQR_deming_forresid = mcreg(x = C2ST_maxIQR$is_temp_med, 
                                  y = C2ST_maxIQR$surface_temp_median, 
                                  method.reg = 'Deming')
C2ST_maxIQR$opt_resid = MCResult.getResiduals(C2_maxIQR_deming_forresid)$optimized
C2ST_maxIQR$filter = 'IQR'

# deming regression for C2 without freezing temps and within IQR and data from the buoy only
C2_cloud_deming = deming::deming(C2ST_cloud$surface_temp_median ~ 
                                        C2ST_cloud$is_temp_med)
C2_cloud_deming_forresid = mcreg(x = C2ST_cloud$is_temp_med, 
                                  y = C2ST_cloud$surface_temp_median, 
                                  method.reg = 'Deming')
C2ST_cloud$opt_resid = MCResult.getResiduals(C2_cloud_deming_forresid)$optimized
C2ST_cloud$filter = 'cloud'

#deming regress for C2 with kurtosis >= 2
C2_kurtosis_deming = deming::deming(C2ST_kurtosis$surface_temp_median ~ 
                                   C2ST_kurtosis$is_temp_med)
C2_kurtosis_deming_forresid = mcreg(x = C2ST_kurtosis$is_temp_med, 
                                 y = C2ST_kurtosis$surface_temp_median, 
                                 method.reg = 'Deming')
C2ST_kurtosis$opt_resid = MCResult.getResiduals(C2_kurtosis_deming_forresid)$optimized
C2ST_kurtosis$filter = 'kurtosis'
```

# Presentation and discussion of filter performance

## Comparison of filter performance

```{r, fig.dim=c(10, 6)}
# Plot Deming regression for all filters to examine performance ####

DemingFigure_a <- ggplot(C2ST, aes(x = is_temp_med, y = surface_temp_median)) +
  geom_abline(slope = 1, intercept = 0, color = '#006cd1', size = 0.75) +
  geom_point() +
  #add deming regression and prediction intervals for C2
  geom_abline(intercept = C2_deming$coefficients[1], slope = C2_deming$coefficients[2], size = 0.75) +
  geom_abline(intercept = C2_deming$ci[1,1], slope = C2_deming$ci[2,1], linetype = 3, size = 0.75) +
  geom_abline(intercept = C2_deming$ci[1,2], slope = C2_deming$ci[2,2], linetype = 3, size = 0.75) +
  geom_text(label = paste0('r = ', round(cor(C2ST$surface_temp_median, C2ST$is_temp_med), digits = 3)),
            x = 2,
            y = 25,
            size = 4,
            hjust = 0)+
  geom_text(label = paste0('n = ', length(C2ST$date)),
            x = 2,
            y = 23,
            size = 4,
            hjust = 0)+
  labs(x = '',
       y = 'median Landsat-derived\nsurface temperature (deg C)',
       title = 'Collection 2',
       subtitle = '') +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5)) +
  coord_cartesian(xlim = c(0, 27),
                  ylim = c(0, 27))

DemingFigure_b <- ggplot(C2ST_freeze, aes(x = is_temp_med, y = surface_temp_median)) +
  geom_abline(slope = 1, intercept = 0, color = '#006cd1', size = 0.75) +
  geom_point() +
  #add deming regression and prediction intervals for C2 filtered for freezing mins
  geom_abline(intercept = C2_freeze_deming$coefficients[1], slope = C2_freeze_deming$coefficients[2], size = 0.75) +
  geom_abline(intercept = C2_freeze_deming$ci[1,1], slope = C2_freeze_deming$ci[2,1], linetype = 3, size = 0.75) +
  geom_abline(intercept = C2_freeze_deming$ci[1,2], slope = C2_freeze_deming$ci[2,2], linetype = 3, size = 0.75) +
  geom_text(label = paste0('r = ', round(cor(C2ST_freeze$surface_temp_median, C2ST_freeze$is_temp_med), digits = 3)),
            x = 2,
            y = 25,
            size = 4,
            hjust = 0)+
  geom_text(label = paste0('n = ', length(C2ST_freeze$date)),
            x = 2,
            y = 23,
            size = 4,
            hjust = 0)+
  labs(x = '',
       y = '\n',
       title = 'Collection 2',
       subtitle = 'freeze') +
    theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  coord_cartesian(xlim = c(0, 27),
                  ylim = c(0, 27))

DemingFigure_c <- ggplot(C2ST_maxIQR, aes(x = is_temp_med, y = surface_temp_median)) +
  geom_abline(slope = 1, intercept = 0, color = '#006cd1', size = 0.75) +
  geom_point() +
  #add deming regression and prediction intervals for C2 filtered for sub zero and maxIQR
  geom_abline(intercept = C2_maxIQR_deming$coefficients[1], slope = C2_maxIQR_deming$coefficients[2], size = 0.75) +
  geom_abline(intercept = C2_maxIQR_deming$ci[1,1], slope = C2_maxIQR_deming$ci[2,1], linetype = 3, size = 0.75) +
  geom_abline(intercept = C2_maxIQR_deming$ci[1,2], slope = C2_maxIQR_deming$ci[2,2], linetype = 3, size = 0.75) +
  geom_text(label = paste0('r = ', round(cor(C2ST_maxIQR$surface_temp_median, C2ST_maxIQR$is_temp_med), digits = 3)),
            x = 2,
            y = 25,
            size = 4,
            hjust = 0)+
  geom_text(label = paste0('n = ', length(C2ST_maxIQR$date)),
            x = 2,
            y = 23,
            size = 4,
            hjust = 0)+
  labs(x = '',
       y = '\n',
       title = 'Collection 2',
       subtitle = 'IQR') +
    theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  coord_cartesian(xlim = c(0, 27),
                  ylim = c(0, 27))

DemingFigure_d <- ggplot(C2ST_kurtosis, aes(x = is_temp_med, y = surface_temp_median)) +
  geom_abline(slope = 1, intercept = 0, color = '#006cd1', size = 0.75) +
  geom_point() +
  #add deming regression and prediction intervals for C2 filtered for sub zero and kurtosis
  geom_abline(intercept = C2_kurtosis_deming$coefficients[1], slope = C2_kurtosis_deming$coefficients[2], size = 0.75) +
  geom_abline(intercept = C2_kurtosis_deming$ci[1,1], slope = C2_kurtosis_deming$ci[2,1], linetype = 3, size = 0.75) +
  geom_abline(intercept = C2_kurtosis_deming$ci[1,2], slope = C2_kurtosis_deming$ci[2,2], linetype = 3, size = 0.75) +
  geom_text(label = paste0('r = ', round(cor(C2ST_kurtosis$surface_temp_median, C2ST_kurtosis$is_temp_med), digits = 3)),
            x = 2,
            y = 25,
            size = 4,
            hjust = 0)+
  geom_text(label = paste0('n = ', length(C2ST_kurtosis$date)),
            x = 2,
            y = 23,
            size = 4,
            hjust = 0)+
  labs(x = expression(bold(paste(italic('in-situ'), ' median water temp (deg C)'))),
       y = 'median Landsat-derived\nsurface temperature (deg C)',
       title = 'Collection 2',
       subtitle = 'kurtosis') +
    theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  coord_cartesian(xlim = c(0, 27),
                  ylim = c(0, 27))

DemingFigure_e <- ggplot(C2ST_cloud, aes(x = is_temp_med, y = surface_temp_median)) +
  geom_abline(slope = 1, intercept = 0, color = '#006cd1', size = 0.75) +
  geom_point() +
  #add deming regression and prediction intervals for C2 filtered for sub zero and cloud
  geom_abline(intercept = C2_cloud_deming$coefficients[1], slope = C2_cloud_deming$coefficients[2], size = 0.75) +
  geom_abline(intercept = C2_cloud_deming$ci[1,1], slope = C2_cloud_deming$ci[2,1], linetype = 3, size = 0.75) +
  geom_abline(intercept = C2_cloud_deming$ci[1,2], slope = C2_cloud_deming$ci[2,2], linetype = 3, size = 0.75) +
  geom_text(label = paste0('r = ', round(cor(C2ST_cloud$surface_temp_median, C2ST_cloud$is_temp_med), digits = 3)),
            x = 2,
            y = 25,
            size = 4,
            hjust = 0)+
  geom_text(label = paste0('n = ', length(C2ST_cloud$date)),
            x = 2,
            y = 23,
            size = 4,
            hjust = 0)+
  labs(x = expression(bold(paste(italic('in-situ'), ' median water temp (deg C)'))),
       y = '\n',
       title = 'Collection 2',
       subtitle = 'cloud') +
    theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  coord_cartesian(xlim = c(0, 27),
                  ylim = c(0, 27))

DemingFigure_f <- ggplot(C2ST_maxrange, aes(x = is_temp_med, y = surface_temp_median)) +
  geom_abline(slope = 1, intercept = 0, color = '#006cd1', size = 0.75) +
  geom_point() +
  #add deming regression and prediction intervals for C2 filtered for sub zero and maxrange
  geom_abline(intercept = C2_maxrange_deming$coefficients[1], slope = C2_maxrange_deming$coefficients[2], size = 0.75) +
  geom_abline(intercept = C2_maxrange_deming$ci[1,1], slope = C2_maxrange_deming$ci[2,1], linetype = 3, size = 0.75) +
  geom_abline(intercept = C2_maxrange_deming$ci[1,2], slope = C2_maxrange_deming$ci[2,2], linetype = 3, size = 0.75) +
  geom_text(label = paste0('r = ', round(cor(C2ST_maxrange$surface_temp_median, C2ST_maxrange$is_temp_med), digits = 3)),
            x = 2,
            y = 25,
            size = 4,
            hjust = 0)+
  geom_text(label = paste0('n = ', length(C2ST_maxrange$date)),
            x = 2,
            y = 23,
            size = 4,
            hjust = 0)+
  labs(x = expression(bold(paste(italic('in-situ'), ' median water temp (deg C)'))),
       y = '\n',
       title = 'Collection 2',
       subtitle = 'range') +
    theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  coord_cartesian(xlim = c(0, 27),
                  ylim = c(0, 27))


DemingFigure <- plot_grid(DemingFigure_a, DemingFigure_b, DemingFigure_c, DemingFigure_d, DemingFigure_e, DemingFigure_f,
                   ncol = 3,
                   labels = c('a', 'b', 'c', 'd', 'e', 'f', '', 'g', ''),
                   label_x = 0.15)

DemingFigure
```
Figure S2. Deming regressions for 6 datasets of Landsat Collection 2 surface temperature product 

## Summarize the slope and intercepts for each of the Deming regressions

```{r, fig.dim = c(8, 4)}
# Plot slope and intercept with 95%ci ####
slope_int_table <- NULL

slope_int_table$model = c( 'C2ST', 'C2ST_freeze', 'C2ST_maxrange', 'C2ST_kurtosis', 'C2ST_maxIQR', 'C2ST_cloud')
slope_int_table$slope = c(C2_deming$coefficients[2],
                          C2_freeze_deming$coefficients[2],
                          C2_maxrange_deming$coefficients[2],
                          C2_kurtosis_deming$coefficients[2],
                          C2_maxIQR_deming$coefficients[2],
                          C2_cloud_deming$coefficients[2])
slope_int_table$intercept = c(C2_deming$coefficients[1],
                              C2_freeze_deming$coefficients[1],
                              C2_maxrange_deming$coefficients[1],
                              C2_kurtosis_deming$coefficients[1],
                              C2_maxIQR_deming$coefficients[1],
                              C2_cloud_deming$coefficients[1])
slope_int_table$slope_se = c(C2_deming$se[2],
                             C2_freeze_deming$se[2],
                             C2_maxrange_deming$se[2],
                             C2_kurtosis_deming$se[2],
                             C2_maxIQR_deming$se[2],
                             C2_cloud_deming$se[2])
slope_int_table$int_se = c(  C2_deming$se[1],
                             C2_freeze_deming$se[1],
                             C2_maxrange_deming$se[1],
                             C2_kurtosis_deming$se[1],
                             C2_maxIQR_deming$se[1],
                             C2_cloud_deming$se[1])
slope_int_table <- as.data.frame(slope_int_table)

slope_int_table <- slope_int_table %>% 
  pivot_longer(cols = c(slope, intercept), names_to = 'var', values_to = 'value') %>% 
  mutate(se = case_when(var == 'slope' ~ slope_se,
                        var == 'intercept' ~ int_se,
                        TRUE ~ NA_real_),
         u95 = value + se,
         l95 = value - se) %>% 
  select(-slope_se, -int_se) %>% 
  mutate(model = factor(model, 
                        levels = c('C2ST', 'C2ST_freeze','C2ST_maxIQR', 'C2ST_kurtosis', 'C2ST_cloud', 'C2ST_maxrange'),
                        labels = c('Collection 2', 'Collection 2\nfreeze', 'Collection 2\nIQR', 'Collection 2\nkurtosis', 'Collection 2\ncloud','Collection 2\nrange'))) %>% 
  mutate(regression = 'Deming')

slope_fig <- slope_int_table %>% 
  filter(var == 'slope') %>% 
  ggplot(., aes(x = model, y = value)) +
  geom_point() +
  geom_pointrange(aes(ymin = l95, ymax = u95))+
  geom_abline(intercept = 1, slope = 0, color = '#454545', lty=2) +
  labs(x = NULL,
       y = 'estimated slope') +
  coord_cartesian(ylim = c(0.85, 1.15)) +
  theme_bw()
int_fig <- slope_int_table %>% 
  filter(var == 'intercept') %>% 
  ggplot(., aes(x = model, y = value)) +
  geom_point() +
  geom_pointrange(aes(ymin = l95, ymax = u95))+
  geom_abline(intercept = 0, slope = 0, color = '#454545', lty=2) +
  labs(x = NULL,
       y = 'estmiated intercept') +
  coord_cartesian(ylim = c(-3.2, 0)) +
  theme_bw()

slope_int_fig <- plot_grid(slope_fig, int_fig,
                           ncol = 1,
                           labels = c('a', 'b'),
                           label_size = 12)
slope_int_fig
```
Figure S3.


# Literature Citations

Cook M, Schott JR, Mandel J, Raqueno N. Development of an Operational Calibration Methodology for the Landsat Thermal Data Archive and Initial Testing of the Atmospheric Compensation Component of a Land Surface Temperature (LST) Product from the Archive. Remote Sensing. 2014; 6(11):11244-11266. https://doi.org/10.3390/rs61111244

Deming, W. E. 1943. Statistical adjustment of data. Dover Publications, 1985.